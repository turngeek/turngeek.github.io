<!DOCTYPE html>
<!-- paulirish.com/2008/conditional-stylesheets-vs-css-hacks-answer-neither/ --> 
<!--[if lt IE 7 ]> <html lang="en-US" class="no-js ie6"> <![endif]-->
<!--[if IE 7 ]>    <html lang="en-US" class="no-js ie7"> <![endif]-->
<!--[if IE 8 ]>    <html lang="en-US" class="no-js ie8"> <![endif]-->
<!--[if IE 9 ]>    <html lang="en-US" class="no-js ie9"> <![endif]-->
<!--[if (gt IE 9)|!(IE)]><!--><html lang="en-US" class="no-js"> <!--<![endif]-->
<!-- Le HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script src="https://html5shim.googlecode.com/svn/trunk/html5.js">
      </script>
    <![endif]-->
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta itemprop='alternativeHeadline' content='Java EE 7 in a Working Week' id='alternativeHeadline'>
<meta itemprop='author' content='Marcus Schiesser and Martin Schmollinger' id='author'>
<meta itemprop='copyrightHolder' content='dpunkt.verlag GmbH. Authorized translation of the German edition titled "Workshop Java EE 7. Ein praktischer Einstieg in die Java Enterprise Edition mit dem Web Profile", 2nd edition. ISBN 978-3-86490-195-9' id='copyrightHolder'>
<meta itemprop='copyrightYear' content='2015' id='copyrightYear'>
<meta itemprop='datePublished' content='2015-10-18' id='datePublished'>
<meta itemprop='description' content='The Cloud Tutorial Series Java EE describes how to develop a sample web application using the Java EE platform using a Cloud IDE. You can jump start into development without any special installations.' id='description'>
<meta itemprop='image' content='/javaee7inaweek/wp-content/uploads/sites/6/2015/10/javaee7inaweek.jpg' id='image'>
<meta itemprop='inLanguage' content='en' id='inLanguage'>
<meta itemprop='publisher' content='TurnGeek' id='publisher'>
<link rel="shortcut icon" href="/javaee7inaweek/wp-content/plugins/pressbooks/themes-book/pressbooks-custom-css/favicon.ico" />
<title>I.2 The Component Architecture of Java EE 7 | Cloud Tutorial Series &#8211; Java EE 7</title>
<link rel="profile" href="http://gmpg.org/xfn/11" />
<link rel="pingback" href="/javaee7inaweek/xmlrpc.php" />

		<script type="text/javascript">
			window._wpemojiSettings = {"baseUrl":"http:\/\/s.w.org\/images\/core\/emoji\/72x72\/","ext":".png","source":{"concatemoji":"http:\/\/www.turngeek.press\/javaee7inaweek\/wp-includes\/js\/wp-emoji-release.min.js?ver=4.4"}};
			!function(a,b,c){function d(a){var c=b.createElement("canvas"),d=c.getContext&&c.getContext("2d");return d&&d.fillText?(d.textBaseline="top",d.font="600 32px Arial","flag"===a?(d.fillText(String.fromCharCode(55356,56806,55356,56826),0,0),c.toDataURL().length>3e3):("simple"===a?d.fillText(String.fromCharCode(55357,56835),0,0):d.fillText(String.fromCharCode(55356,57135),0,0),0!==d.getImageData(16,16,1,1).data[0])):!1}function e(a){var c=b.createElement("script");c.src=a,c.type="text/javascript",b.getElementsByTagName("head")[0].appendChild(c)}var f,g;c.supports={simple:d("simple"),flag:d("flag"),unicode8:d("unicode8")},c.DOMReady=!1,c.readyCallback=function(){c.DOMReady=!0},c.supports.simple&&c.supports.flag&&c.supports.unicode8||(g=function(){c.readyCallback()},b.addEventListener?(b.addEventListener("DOMContentLoaded",g,!1),a.addEventListener("load",g,!1)):(a.attachEvent("onload",g),b.attachEvent("onreadystatechange",function(){"complete"===b.readyState&&c.readyCallback()})),f=c.source||{},f.concatemoji?e(f.concatemoji):f.wpemoji&&f.twemoji&&(e(f.twemoji),e(f.wpemoji)))}(window,document,window._wpemojiSettings);
		</script>
		<style type="text/css">
img.wp-smiley,
img.emoji {
	display: inline !important;
	border: none !important;
	box-shadow: none !important;
	height: 1em !important;
	width: 1em !important;
	margin: 0 .07em !important;
	vertical-align: -0.1em !important;
	background: none !important;
	padding: 0 !important;
}
</style>
<link rel='stylesheet' id='pressbooks-book-css'  href='/javaee7inaweek/wp-content/plugins/pressbooks/themes-book/pressbooks-book/style.css' type='text/css' media='screen, print' />
<link rel='stylesheet' id='pressbooks-custom-css-css'  href='/javaee7inaweek/wp-content/uploads/sites/6/custom-css/web.css?ver=4.4' type='text/css' media='screen' />
<script type='text/javascript' src='/javaee7inaweek/wp-includes/js/jquery/jquery.js?ver=1.11.3'></script>
<script type='text/javascript' src='/javaee7inaweek/wp-includes/js/jquery/jquery-migrate.min.js?ver=1.2.1'></script>
<script type='text/javascript' src='/javaee7inaweek/wp-content/plugins/pressbooks/themes-book/pressbooks-book/js/script.js?ver=1.0'></script>
<script type='text/javascript' src='/javaee7inaweek/wp-content/plugins/pressbooks/themes-book/pressbooks-book/js/pop-out.js?ver=1.0'></script>
<link rel='https://api.w.org/' href='/javaee7inaweek/wp-json/' />
<link rel='prev' title='I.1 Java EE 7 – The Standard for Enterprise Java' href='/javaee7inaweek/chapter/i-1-java-ee-7-the-standard-for-enterprise-java/' />
<link rel='next' title='I.3 The Target Architecture' href='/javaee7inaweek/chapter/i-3-the-target-architecture/' />
<meta name="generator" content="WordPress 4.4" />
<link rel='shortlink' href='/javaee7inaweek/?p=42' />
<link rel="alternate" type="application/json+oembed" href="/javaee7inaweek/wp-json/oembed/1.0/embed?url=http%3A%2F%2Fwww.turngeek.press%2Fjavaee7inaweek%2Fchapter%2Fi-2-the-component-architecture-of-java-ee-7%2F" />
<link rel="alternate" type="text/xml+oembed" href="/javaee7inaweek/wp-json/oembed/1.0/embed?url=http%3A%2F%2Fwww.turngeek.press%2Fjavaee7inaweek%2Fchapter%2Fi-2-the-component-architecture-of-java-ee-7%2F&#038;format=xml" />
<style type="text/css">
/* <![CDATA[ */
img.latex { vertical-align: middle; border: none; background: none; }
/* ]]> */
</style>

</head>
<body class="single single-chapter postid-42" id="i.2thecomponentarchitectureofjavaee7">
	<!-- Faccebook share js sdk -->
	<div id="fb-root"></div>
	<script>(function(d, s, id) {
	  var js, fjs = d.getElementsByTagName(s)[0];
	  if (d.getElementById(id)) return;
	  js = d.createElement(s); js.id = id;
	  js.src = "//connect.facebook.net/en_US/all.js#xfbml=1";
	  fjs.parentNode.insertBefore(js, fjs);
	}(document, "script", "facebook-jssdk"));</script>

<!-- a11y toolbar -->
<div class="a11y-toolbar">
	</div>
<!-- // a11y toolbar -->


	   	 
		<span itemscope itemtype="http://schema.org/WebPage" itemref="about copyrightHolder copyrightYear inLanguage publisher">		
		<div class="nav-container">
				<nav>
			
			 		<!-- Book Title -->
				    <h1 class="book-title"><a href="/javaee7inaweek/" title="Cloud Tutorial Series &#8211; Java EE 7" rel="home">Cloud Tutorial Series &#8211; Java EE 7</a></h1>
			    
			   
			    
					    <div class="sub-nav-left">
							<!-- Logo -->
							<h2 class="pressbooks-logo"><a href="/">TurnGeek Books</a></h2>
					    </div> <!-- end .sub-nav-left -->
			    
			    <div class="sub-nav-right">
			    
					    	
						
						<!-- --> 
				
				</div> <!-- end .sub-nav-right -->
			</nav>
			      
			  <div class="sub-nav">       
			     <!-- Author Name -->   
			    <div class="author-wrap"> 
			    									     	<h3>Marcus Schiesser and Martin Schmollinger</h3>
		     					     </div> <!-- end .author-name -->
		     
			  </div><!-- end sub-nav -->  
			    
				 
		</div> <!-- end .nav-container -->

	<div class="wrapper"><!-- for sitting footer at the bottom of the page -->	    
			<div id="wrap">	    
				<div id="content">

	 	
							<h2 class="entry-title">I.2 The Component Architecture of Java EE 7</h2>
					<div class="nav">
  	<span class="previous"><a href="/javaee7inaweek/chapter/i-1-java-ee-7-the-standard-for-enterprise-java/">Previous</a></span>
  <!-- 	<h2 class="entry-title">I.2 The Component Architecture of Java EE 7</h2> -->
  	<span class="next"><a href="/javaee7inaweek/chapter/i-3-the-target-architecture/">Next</a></span>
    </div>				<div id="post-42" class="type-1 post-42 chapter type-chapter status-publish hentry">
					
					<div class="entry-content">
					  				    									
					<div class="textbox shaded">
<p><strong><strong>Note</strong></strong></p>
<p>Readers wishing to learn more about the programming of components are encouraged – either in parallel to this section, or upon finishing it – to work off our <a href="/javaeeinaday/" target="_blank">Cloud Tutorial Java EE in a Day</a>, where explanations of the component technologies are supported by small program codes. While not sufficient to elucidate the individual technologies in their entirety, this section can nevertheless help readers enhance their understanding.</p>
</div>
<h3>I.2.1 The Components of the Web Layer</h3>
<p><em>Java servlets</em> technology was the first Java API for implementing Web clients. A servlet is a Java class that supports request-response protocols &#8211; HTTP in particular &#8211; within the application server.</p>
<p>Unfortunately, the creation of web pages using Java servlets can easily result in a tangling of presentation and logic. More recent Web technologies are based conceptually on the <em>Model-View-Controller</em> pattern (MVC pattern). Although, in principle, it is possible to implement the MVC pattern with Java servlets, a clean separation of presentation (view) and logic (controller) is not easy to achieve. While, for this reason, Java servlets are no longer directly used for the production of web pages, they frequently serve as intermediaries in web frameworks between the requesting Web clients and the components responsible for the generation of the response.</p>
<div class="textbox shaded">
<p><strong><strong><a href="https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller" target="_blank">Model-View-Controller</a> (MVC)</strong></strong></p>
<p>The MVC is a pattern that defines how presentation, logic and data are to be separated within an application. The objective of this separation is to improve the program structure and thus the maintainability, extensibility and re-usability of the code.The “model” encapsulates the data and, depending on the MVC expression, can also contain the business logic. The “view” displays the model and the “controller” implements the application control. The controller responds to user interaction within the view and, where necessary, updates the data in the model. Depending on the characteristics of the MVC, the view then adapts automatically or is informed of changes by the controller.</p>
</div>
<p>In time, the use of Java Servlet technology meant that web components began to be created at a higher level of abstraction. JavaServer Pages (JSP) and JavaServer Faces (JSF) were used to do this.</p>
<p>While a Java servlet is a Java class, JSP and JSF components consist of a text-based page definition and of classes that implement the controller logic in the background. The description of the view is accomplished with a V<em>iew Declaration Language (VDL for short</em>); depending on the technology, this is based on either HTML or XHTML.</p>
<p>Models are implemented as classes; however, because they are needed in all layers of the application, they are not counted strictly amongst the web components. The objects of the model classes are therefore also referred to as <em>transfer objects</em>, since they are frequently passed from the client layer up to the persistence layer and vice versa. The terms POJO and JavaBean are often heard in this context.</p>
<div class="textbox shaded"><strong><a href="http://www.martinfowler.com/bliki/POJO.html" target="_blank">POJOs</a> (Plain Old Java Objects)<br />
</strong><br />
are implemented using ordinary Java classes, independently of any additional framework, and are based only on the Java programming language. However the term is often applied more flexibly in practice. If a class contains additional annotations, for example, it is still often referred to as POJO, because annotations are just metadata.</div>
<div class="textbox shaded"><strong><a href="https://en.wikipedia.org/wiki/JavaBeans" target="_blank">JavaBeans</a><br />
</strong><br />
are Java classes that are often used as data containers or to encapsulate recurring tasks. JavaBeans share a common set of features: they have a public constructor with no parameters, they are serializable and there are public access methods (getters/setters) for each of their attributes (see <a href="http://docs.oracle.com/javase/tutorial/javabeans/index.html" target="_blank">JavaBeans tutorial</a>).</div>
<h4>JavaServer Pages</h4>
<p><em>JavaServer Pages</em> enable the development of a view with a view declaration language based on HTML. It is possible, for the purpose of implementing the controller logic, to embed Java declarations, Java code and Java statements in the page using a special syntax. JavaBeans can also be published via directives, and their properties accessed. The <em>JavaServer Pages Standard Tag Library</em> (JSTL) is an extension of the JSP technology and is designed to enable the adding of special tags for frequently required tasks and UI components. The use of JSTL simplifies and standardizes the creation of JSP views. JSP is no longer the preferred view technology for the Java EE standard, so we will refrain from discussing it further here.</p>
<h4>JavaServer Faces</h4>
<p>In earlier versions of JSF, JSP served as a view declaration language. In version 2.0, JSF introduced its own view technology, <em>Facelets</em>, which was based on XHTML. Facelets offer several advantages over JSP, including the template system explained in <a title="4.4" href="/javaee7/chapter/4-4/">section 4.4</a>. In addition to the MVC pattern, JSF supplies a UI component model, including <em>event handling,</em> that functions analogously to the UI libraries for desktop applications (e.g. JavaFX). The UI components are made available in Facelets using tags and JSF has its own extensive tag libraries.</p>
<p>The UI components of a view that are coded using Facelet tags are represented at runtime on the application server by instances of JSF API classes. The view corresponds to a component tree as a whole, i.e., the network of instances is represented by a tree structure. The component tree is created from the Facelet when the Web client first accesses a view and is used thereafter as the basis for the processing of further requests to the view by Web clients.</p>
<p>In the browser, the user has only a representation of the component tree in HTML/JavaScript to work with. This communicates with the server using HTTP. The objective of JSF implementation is to process Web client requests to the view and to generate the representation of a new view (when navigating to another page) or a modified version of the original view (as a result of action taken) and return it as a response. To do this, JSF implements a complex processing model consisting of six phases, which begins with the restoration of the component tree for the view and ends with the rendering of the response.</p>
<p>In the intermediate stages, request parameters can be acquired, converted and validated and attributes of the models bound to UI components can be updated; such attributes can also be called up for the event handlers of UI components. In each stage, events can occur (e.g. validation errors) that result in a direct jump to the last phase of the model to generate a response (e.g. in the case of a page with error messages). Fig. I-2 is a schematic representation of a JSF request (Faces request) within the context of the execution environment.</p>
<p><a href="/images/javaee7inaweek/chapteri/i-2.png" target="_blank"><img src="/images/javaee7inaweek/chapteri/i-2.png" alt="Schematic representation of the handling of a JavaServer Faces request by the server" width="100%" /></a><br />
<strong>Fig. I-2     </strong>Schematic representation of the handling of a JavaServer Faces request by the server</p>
<p>In the case of JSF, either JSF managed beans or CDI Beans can be used as the controller. Both types of beans can be embedded in the view by using <em>expression language</em> (EL) in the page definition. This book will use CDI beans for this purpose, since they offer better opportunities for implementing a flexible software architecture.</p>
<p>Tab. I-1 briefly summarizes the different web technologies of the Java EE standard.</p>
<table>
<tbody>
<tr>
<td><strong>Web Technology</strong></td>
<td><strong>Summary</strong></td>
</tr>
<tr>
<td>Java Servlets</td>
<td>No longer used to directly generate a view, as it does not provide enough separation between presentation and logic. However, it is still used to implement higher-level abstraction of web frameworks (eg JSP, JSF).</td>
</tr>
<tr>
<td>JavaServer Pages</td>
<td>Outdated technology for designing the view. Logic is incorporated directly in the view via JavaBeans or Java code using special tags. Will continue to be supported for compatibility reasons.</td>
</tr>
<tr>
<td>JavaServer Faces</td>
<td>Current technology for designing the view. Facelets are used to provide the view on the basis of XHTML. JSF supplies a UI component model with event handling. Logic is integrated in the view via JSF Managed Beans or CDI using event processing or special tags.</td>
</tr>
</tbody>
</table>
<p><strong>Tab. I-1     </strong>Web technologies of the Java EE standard</p>
<h3>I.2.2 CDI – A Component Type with Plenty of Potential</h3>
<p>CDI Beans are a relatively new type of bean that first appeared in Java EE version 6. Given the situation at the time CDI was introduced, one might wonder why it really was needed at all. Didn’t everything we need for successful development already exist? With JSF Facelets and JSF managed beans (for the view and controller), POJO (for the model) and EJB (for the business logic), we were able to program a multi-tier business application without problems &#8211; weren’t we?</p>
<p>Why, then, did the creators of the Java EE standard choose to supply programmers with another component technology, <em>Contexts and Dependency Injection (CDI)</em>?</p>
<p>On one hand, CDI is a technology that links to the Web layer and the transactional business layer in the same way as JSF managed beans: CDI beans can also be accessed in Facelets using the Expression Language (EL). On another hand, the concept of CDI goes far beyond JSF managed beans in terms of its complexity: it is a technology that links beans at runtime through <em>dependency injection</em> (DI). Beans are not generated, but are requested by means of declaration and annotation (<code>@Inject</code>) at certain points in the process. The container ensures the availability of the beans at runtime. CDI beans are aimed at increasing the maintainability of applications and improving their extensibility and testability. This is achieved through the consistent application of DI and other complementary approaches (e.g. application-wide messages) to components as well as through the clear <i>specification</i> of visibility sections (contexts).</p>
<div class="textbox shaded"><strong>Dependency Injection (DI)<br />
</strong><br />
is a pattern that transfers the tasks of object creation, deployment, and management from the user of the object to the runtime environment (container). The user defines only what they wish to have at each point (type, scope, number), and the runtime environment takes care of everything else. This simplifies access, enables loose coupling between objects and ensures that type safety is preserved.</div>
<p>CDI is a general, layer-independent container technology. CDI is extensible, which enables it to take on layer-specific tasks. The framework <em>Seam 3</em>, for example, offers a number of extensions, including one for transactions, which are usually the domain of Enterprise Java Beans (EJBs). CDI is more general than other purpose-built bean technologies. The CDI container can be embedded both in Java EE environments and in others; in J2SE applications, for example. We will learn more about CDI and the ways in which it differs from other component technologies in our <strong>Cloud Tutorial CDI in a Day</strong> (coming soon).</p>
<h3>I.2.3 Enterprise Java Beans</h3>
<p>Enterprise JavaBeans (EJBs) are components that implement business logic and thus belong to the business layer of a multi-layer application. They are managed by the application server’s <em>EJB container</em>. The container gives the EJBs access to key business application services such as transaction control and security mechanisms. The EJBs can be considered the internal &#8220;service beans&#8221; of Java EE applications. EJBs are the first choice whenever business logic is required alongside transactional behavior, since they incorporate this behavior by default.</p>
<p>It is not only Web-tier components that have evolved over the years; there have also been changes in the EJBs, of which there initially existed three types. Two of them, session beans and message-driven beans, still exist today &#8211; though the amount of programming effort required to create them has been significantly reduced since Java EE 5. <em>Entity beans,</em> which were designed as persistent domain classes, were later abolished and the Java-wide unified <em>Java Persistence API</em> (JPA) introduced instead.</p>
<p>While JSF managed beans and CDI are primarily used as controllers in the Web application, the &#8220;heavyweight&#8221; transactional business logic is implemented with EJBs. EJBs are only involved in a view via the respective controller, never directly. Just as in CDI, Java EE 7 makes EJBs available within the controller classes via the simple use of dependency injection with annotations. The same mechanism can be used when EJBs are used in combination with each other.</p>
<h3>I.2.4 Java Persistence API (JPA)</h3>
<p>JPA is not a Java EE component technology; rather, it is a Java-wide technology for mapping object meshes to the relational structures of a database. This means that object-relational mapping can be defined for any application, from those suited for personal desktop use to distributed, multi-layered business applications. JPA makes it appear as though an object-oriented database is available to the Java classes, although a relational database system is actually used.</p>
<p>Prior to determining the mapping, it’s essential to consider which objects should actually be persisted. Usually, these are clearly identifiable information objects. A bank application, for example, would contain appropriate domain classes for storing customer and account data.</p>
<p>Objects are uniquely allocated using a unique key for the class. Domain classes with a unique key are also known as <em>entities</em>. It does not always make sense to map an entity to exactly one table; however, JPA allows for plenty of variation in this regard.</p>
<p>The mapping of a class and its attributes to a relational database is defined using annotations. The annotation @Entity, for example, identifies a class as an entity, while @Id can be used to define an attribute of the class as a key and @Table can be used to assign a table name in the database explicitly to the entity.</p>
<p>Thus the schema of the target database can be created using the metadata of the entities during deployment (or an existing schema can be verified for use). In addition, data can be stored correctly in the database tables at runtime with the help of metadata. This task is undertaken by JPA classes (e.g. javax.persistence.EntityManager).</p>
<p>In Java EE applications, JPA classes are used within EJBs that provide controllers of the Web tier with transactional methods for the persistence of entities. Fig. I-3 is a visual representation of the object-relational mapping concept. The diagram shows an entity “Donation”, whose attributes are mapped to a &#8220;Donation&#8221; table in a relational database.</p>
<p><a href="/images/javaee7inaweek/chapteri/i-3.png" target="_blank"><img src="/images/javaee7inaweek/chapteri/i-3.png" alt="Object-relational mapping of an instance of the entity" width="100%" /></a><br />
<strong>Fig. I-3</strong>     Object-relational mapping of an instance of the entity “Donation” to a table “Donation” in a relational database</p>
<h3>I.2.5 The Java EE Profile</h3>
<p>The introduction of the Java EE web profile in Java EE version 6 heralded the arrival of a completely new approach involving customized Java application servers for application domains. Despite its numerous simplifications, the complete Java EE standard is very extensive and complex. The Java EE profiles take account of the fact that not all projects require the complete range of Java EE features and capabilities.</p>
<p>A profile corresponds to a standardized partial stack of the Java EE standard; that is, a profile defines exactly which of the Java EE standard APIs are included. The aim is not only to define custom-tailored API packages for developers to use for a specific purpose, but also to allow for highly specialized servers. Discounting the <em>full profile</em>, the <em>Web Profile</em> that arrived with version 6 is the first and to date only Java EE profile to have been released. As the name suggests, it has been tailored specifically for web projects, so we have afforded it special attention in this book. Java EE 7 did not introduce any further profiles, but instead focused on extending the Web Profile. Tab. I-2 lists the most important technologies. A complete overview can be found in the <a href="http://download.oracle.com/otndocs/jcp/java_ee-7-pfd-spec/index.html" target="_blank">Java EE 7 specification</a>.</p>
<table>
<tbody>
<tr>
<td><strong>Technology</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>Java Servlets 3.1</td>
<td>Web technologies for different levels of abstraction</td>
</tr>
<tr>
<td>JavaServer Pages (JSP) 3.2</td>
</tr>
<tr>
<td>JavaServer Faces (JSF) 2.2</td>
</tr>
<tr>
<td>Expression Language (EL) 3.0</td>
<td>A language that is embeddable in the VDL and used primarily for addressing bean attributes and event handlers</td>
</tr>
<tr>
<td>Standard Tag Library for JavaServer Pages (JSTL) 1.2</td>
<td>Component library for Java Server Pages</td>
</tr>
<tr>
<td>Enterprise JavaBeans (EJB) 3.2 lite</td>
<td>Components for implementing the business logic of an application. The addition of &#8220;lite&#8221; indicates that the full capacity of the EJBs is not available in web profile applications (e.g. no Web service endpoints or message-driven beans)</td>
</tr>
<tr>
<td>Contexts and Dependency Injection (CDI) 1.1</td>
<td>Type of component that can be used as a controller bean for JSF and enables the design of flexible software architectures</td>
</tr>
<tr>
<td>Managed Beans 1.0</td>
<td>Managed beans are used for implementing controller beans in JSF</td>
</tr>
<tr>
<td>Interceptors 1.2</td>
<td>Enables aspect-oriented programming in Java EE applications</td>
</tr>
<tr>
<td>Java Persistence API (JPA) 2.1</td>
<td>Special API for implementing data storage, transactions, data validity checking and object-relational mapping of Java objects in databases</td>
</tr>
<tr>
<td>Java Transaction API (JTA) 1.2</td>
<td>API for transaction management</td>
</tr>
<tr>
<td>Bean Validation 1.1</td>
<td>API for checking the validity of values of attributes or parameters of methods of a bean</td>
</tr>
<tr>
<td>Java API for RESTful Web Services (JAX-RS) 2.0</td>
<td>API for implementing HTTP-based, loosely-coupled web services</td>
</tr>
<tr>
<td>Java API for WebSocket 1.0</td>
<td>API for implementing bidirectional communication channels between the browser and application server</td>
</tr>
<tr>
<td>Java API for JSON Processing (JSON-P) 1.0</td>
<td>API for parsing JSON data</td>
</tr>
</tbody>
</table>
<p><strong>Tab. I-2</strong>     The main technologies of the Java EE 7 Web Profile</p>
<p>In this book, we will familiarize ourselves with these technologies on a step-by-step basis. This will allow us to gain a foothold in the world of Java EE. At certain points, however, we will also find ourselves needing technologies that are not included in the Web Profile if a technology we need is not contained in the Web Profile. Until then, it can be assumed that all APIs used are included in the Web Profile.</p>
<p>We have now gained an overview of the various components of Java EE 7 and the building of a Java EE application. Next, we want to look at how we can make a Java EE application available on an application server.</p>
<h3>I.2.6 Time to Get Started With the Application Server!</h3>
<p>In Java EE applications &#8211; as in ordinary Java desktop applications &#8211; Java archives are used for packaging types (classes, interfaces or enumerated types), Facelets and all other resources (e.g. JavaScript, CSS, property or configuration files and images). However, there are different types of archives. The folder structure within the archives is complex, and is determined by the specification. In particular, the specification defines the types <em>Enterprise Archive</em> (EAR) and <em>Web Archive</em> (WAR) (see Fig. I-4). The former is used for the packaging of Java EE applications that require the entire scope of Java EE capabilities (<em>full profile</em>), the latter is intended for Java EE applications using only the web profile.</p>
<p>Due to the complexity of the archives and the configurations that are partially dependent on application servers, tool support of the archive preparation is highly recommended. The compilation of classes and the packaging of all Java EE application artifacts is referred to as the <em>build</em>. The archive files created in the process can then be passed on to an application server. This is likewise accomplished by tools of the development environment or application servers. The process is called <em>deployment</em> and covers the installation, configuration and deployment of the application in the application server. Following deployment, the application is ready to be used.</p>
<div class="textbox shaded"><strong>Deployment<br />
</strong><br />
The term “deployment” covers the installation, configuration and deployment of the software on the target platform. The term “software distribution” has roughly the same meaning. The result of the deployment process is that the software is ready for use.</div>
<p>&nbsp;</p>
<p><a href="/images/javaee7inaweek/chapteri/i-4.png" target="_blank"><img src="/images/javaee7inaweek/chapteri/i-4.png" alt="Outline of the basic structure of a Java EE 7 web archive (WAR)" width="100%" /></a><br />
<strong>Fig. I-4</strong>     Outline of the basic structure of a Java EE 7 web archive (WAR). Directories within the archive are shown with a double border, files with a single one. Directories other than those illustrated can exist for special properties of the application (e.g. for the template system, the Resource Library Contracts or the Faces Flows of JSF).</p>
<p>&nbsp;</p>
<p>As part of the deployment process, the application server processes the archive files and makes the components contained within them available in the different containers (CDI, Web, EJB) (see Fig. I-5). From this point onwards, the life-cycle of the components is controlled by the containers. The containers also provide interfaces to the application server’s common services and data.</p>
<p>One of the most important services provided by the application server is the naming and directory service. Through it, clients can reference components (such as remotely available EJBs) or other objects and data by specifying their unique names. Access to the naming and directory service is standardized via the <em><a href="https://en.wikipedia.org/wiki/Java_Naming_and_Directory_Interface" target="_blank">Java Naming and Directory Interface (JNDI)</a> API</em>.</p>
<p>&nbsp;</p>
<p><a href="/images/javaee7inaweek/chapteri/i-5.png" target="_blank"><img src="/images/javaee7inaweek/chapteri/i-5.png" alt="Deployment process of a Java EE application" width="100%" /></a><br />
<strong>Fig. I-5    </strong> Deployment process of a Java EE application</p>
<p>In the last section of this chapter, we will outline a typical software architecture for Java EE applications and describe exactly which components and technologies are used. The application to be developed in this book will be based on this architecture.</p>
<h3>Discussion</h3>
<p>Use the message board below to give the authors your feedback or to discuss this page&#8217;s topic with other readers (in English please!). Please don&#8217;t expect the authors to answer directly, but they might update the content of this site according to your feedback.<br />
<script src="/js/disqus.js" type="text/javascript"></script></p>

					</div><!-- .entry-content -->
				</div><!-- #post-## -->

			
				</div><!-- #content -->
			
				<!-- Share buttons -->
	<div class="share-wrap-single">
		<ul class="share share-single">
						<li class="email"><a href="mailto:?subject=I%20wanted%20to%20share%20this%20post%20with%20you%20from%20Cloud%20Tutorial%20Series%20-%20Java%20EE%207&amp;body=I.2%20The%20Component%20Architecture%20of%20Java%20EE%207%20-%20http%3A%2F%2Fwww.turngeek.press%2Fjavaee7inaweek%2Fchapter%2Fi-2-the-component-architecture-of-java-ee-7%2F" title="Email to a friend" target="_blank">Share via Email</a>
			</li>
			<li class="twitter"><a href="https://twitter.com/share" class="twitter-share-button" data-count="horizontal" data-width="97px">Tweet</a>
<script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0];if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src="//platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script></li>
			<li class="facebook"><div class="fb-like" data-send="false" data-layout="button_count" data-width="60" data-show-faces="false"></div></li>
									
		</ul>
	</div><!-- end .share-wrap-single --> 
			
				
		
	<div id="sidebar">

		<ul id="booknav">
		<!-- If Logged in show ADMIN -->
								
				<li class="home-btn"><a href="/javaee7inaweek">Home</a></li>

		<!-- TOC button always there -->
				<li class="toc-btn"><a href="/javaee7inaweek/table-of-contents">Table of Contents</a></li>
			</ul>

		<!-- Pop out TOC only on READ pages -->
						<div id="toc">
			<a href="#" class="close">Close</a>
			<ul>
				<li><h4><!-- Front-matter --></h4></li>
				<li>
					<ul>
																		<li class="front-matter introduction"><a href="/javaee7inaweek/front-matter/introduction/">Introduction</a>
              						</li>
											</ul>
				</li>
								<li><h4>				<a href="/javaee7inaweek/part/main-body/">				I A Profiled Introduction				</a>				</h4></li>
				<li>
					<ul>
																				<li class="chapter type-1"><a href="/javaee7inaweek/chapter/i-1-java-ee-7-the-standard-for-enterprise-java/">I.1 Java EE 7 – The Standard for Enterprise Java</a>
                							</li>
																				<li class="chapter type-1"><a href="/javaee7inaweek/chapter/i-2-the-component-architecture-of-java-ee-7/">I.2 The Component Architecture of Java EE 7</a>
                							</li>
																				<li class="chapter type-1"><a href="/javaee7inaweek/chapter/i-3-the-target-architecture/">I.3 The Target Architecture</a>
                							</li>
																				<li class="chapter type-1"><a href="/javaee7inaweek/chapter/i-4-what-next/">I.4 What Next?</a>
                							</li>
											</ul>
				</li>
								<li><h4>				<a href="/javaee7inaweek/part/3-requirements-of-the-sample-application-my-campaign/">				II Requirements of the Sample Application “My-Campaign”				</a>				</h4></li>
				<li>
					<ul>
																				<li class="chapter type-1"><a href="/javaee7inaweek/chapter/ii-1-introduction/">II.1 Introduction</a>
                							</li>
																				<li class="chapter type-1"><a href="/javaee7inaweek/chapter/ii-2-overview-of-use-cases/">II.2 Overview of Use Cases</a>
                							</li>
																				<li class="chapter type-1"><a href="/javaee7inaweek/chapter/ii-3-domain-classes/">II.3 Domain Classes</a>
                							</li>
																				<li class="chapter type-1"><a href="/javaee7inaweek/chapter/ii-4-use-cases/">II.4 Use Cases</a>
                							</li>
																				<li class="chapter type-1"><a href="/javaee7inaweek/chapter/what-next/">II.5 What Next?</a>
                							</li>
											</ul>
				</li>
								<li><h4><!-- Back-matter --></h4></li>
				<li>
					<ul>
											</ul>
				</li>
			</ul>
		</div><!-- end #toc -->
		

	</div><!-- end #sidebar -->
	
	</div><!-- #wrap -->
	<div class="push"></div>
	
	</div><!-- .wrapper for sitting footer at the bottom of the page -->


<div class="footer">
	<div class="inner">
								
			
						<p class="cie-name"><a href="http://pressbooks.com">Pressbooks.com: Simple Book Production</a></p>
	</div><!-- #inner -->
</div><!-- #footer -->
</span><!-- schema.org -->
<script type='text/javascript' src='/javaee7inaweek/wp-content/plugins/pressbooks/themes-book/pressbooks-book/js/keyboard-nav.js?ver=20130306'></script>
<script type='text/javascript' src='/javaee7inaweek/wp-includes/js/wp-embed.min.js?ver=4.4'></script>
</body>
</html>
