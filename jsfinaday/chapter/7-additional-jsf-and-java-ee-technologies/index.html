<!DOCTYPE html>
<!-- paulirish.com/2008/conditional-stylesheets-vs-css-hacks-answer-neither/ --> 
<!--[if lt IE 7 ]> <html lang="en-US" class="no-js ie6"> <![endif]-->
<!--[if IE 7 ]>    <html lang="en-US" class="no-js ie7"> <![endif]-->
<!--[if IE 8 ]>    <html lang="en-US" class="no-js ie8"> <![endif]-->
<!--[if IE 9 ]>    <html lang="en-US" class="no-js ie9"> <![endif]-->
<!--[if (gt IE 9)|!(IE)]><!--><html lang="en-US" class="no-js"> <!--<![endif]-->
<!-- Le HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script src="https://html5shim.googlecode.com/svn/trunk/html5.js">
      </script>
    <![endif]-->
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta itemprop='author' content='Marcus Schiesser and Martin Schmollinger' id='author'>
<meta itemprop='copyrightHolder' content='dpunkt.verlag GmbH. Authorized translation of the German edition titled "Workshop Java EE 7. Ein praktischer Einstieg in die Java Enterprise Edition mit dem Web Profile", 2nd edition. ISBN 978-3-86490-195-9' id='copyrightHolder'>
<meta itemprop='copyrightYear' content='2015' id='copyrightYear'>
<meta itemprop='datePublished' content='2015-10-13' id='datePublished'>
<meta itemprop='description' content='This Cloud Tutorial is the first of an upcoming series building a web application step by step with Java EE technology. It will see us implement the user interface of the sample application using JavaServer Faces (JSF).' id='description'>
<meta itemprop='image' content='/jsfinaday/wp-content/uploads/sites/5/2015/10/jsfinaday_cover.png' id='image'>
<meta itemprop='inLanguage' content='en' id='inLanguage'>
<meta itemprop='publisher' content='TurnGeek' id='publisher'>
<link rel="shortcut icon" href="/jsfinaday/wp-content/plugins/pressbooks/themes-book/pressbooks-custom-css/favicon.ico" />
<title>7 Additional JSF and Java EE Technologies | Cloud Tutorial &#8211; JavaServer Faces in a Day</title>
<link rel="profile" href="http://gmpg.org/xfn/11" />
<link rel="pingback" href="/jsfinaday/xmlrpc.php" />

		<script type="text/javascript">
			window._wpemojiSettings = {"baseUrl":"http:\/\/s.w.org\/images\/core\/emoji\/72x72\/","ext":".png","source":{"concatemoji":"http:\/\/www.turngeek.press\/jsfinaday\/wp-includes\/js\/wp-emoji-release.min.js?ver=4.4"}};
			!function(a,b,c){function d(a){var c=b.createElement("canvas"),d=c.getContext&&c.getContext("2d");return d&&d.fillText?(d.textBaseline="top",d.font="600 32px Arial","flag"===a?(d.fillText(String.fromCharCode(55356,56806,55356,56826),0,0),c.toDataURL().length>3e3):("simple"===a?d.fillText(String.fromCharCode(55357,56835),0,0):d.fillText(String.fromCharCode(55356,57135),0,0),0!==d.getImageData(16,16,1,1).data[0])):!1}function e(a){var c=b.createElement("script");c.src=a,c.type="text/javascript",b.getElementsByTagName("head")[0].appendChild(c)}var f,g;c.supports={simple:d("simple"),flag:d("flag"),unicode8:d("unicode8")},c.DOMReady=!1,c.readyCallback=function(){c.DOMReady=!0},c.supports.simple&&c.supports.flag&&c.supports.unicode8||(g=function(){c.readyCallback()},b.addEventListener?(b.addEventListener("DOMContentLoaded",g,!1),a.addEventListener("load",g,!1)):(a.attachEvent("onload",g),b.attachEvent("onreadystatechange",function(){"complete"===b.readyState&&c.readyCallback()})),f=c.source||{},f.concatemoji?e(f.concatemoji):f.wpemoji&&f.twemoji&&(e(f.twemoji),e(f.wpemoji)))}(window,document,window._wpemojiSettings);
		</script>
		<style type="text/css">
img.wp-smiley,
img.emoji {
	display: inline !important;
	border: none !important;
	box-shadow: none !important;
	height: 1em !important;
	width: 1em !important;
	margin: 0 .07em !important;
	vertical-align: -0.1em !important;
	background: none !important;
	padding: 0 !important;
}
</style>
<link rel='stylesheet' id='pressbooks-book-css'  href='/jsfinaday/wp-content/plugins/pressbooks/themes-book/pressbooks-book/style.css' type='text/css' media='screen, print' />
<link rel='stylesheet' id='pressbooks-custom-css-css'  href='/jsfinaday/wp-content/uploads/sites/5/custom-css/web.css?ver=1441720892' type='text/css' media='screen' />
<script type='text/javascript' src='/jsfinaday/wp-includes/js/jquery/jquery.js?ver=1.11.3'></script>
<script type='text/javascript' src='/jsfinaday/wp-includes/js/jquery/jquery-migrate.min.js?ver=1.2.1'></script>
<script type='text/javascript' src='/jsfinaday/wp-content/plugins/pressbooks/themes-book/pressbooks-book/js/script.js?ver=1.0'></script>
<script type='text/javascript' src='/jsfinaday/wp-content/plugins/pressbooks/themes-book/pressbooks-book/js/pop-out.js?ver=1.0'></script>
<link rel='https://api.w.org/' href='/jsfinaday/wp-json/' />
<link rel='prev' title='6 Our First Use Case: &#8220;Display and Edit Campaign&#8221;' href='/jsfinaday/chapter/6-our-first-use-case-display-and-edit-campaign/' />
<link rel='next' title='8 Implementation of the Remaining Use Cases' href='/jsfinaday/chapter/8-implementation-of-the-remaining-use-cases/' />
<meta name="generator" content="WordPress 4.4" />
<link rel='shortlink' href='/jsfinaday/?p=30' />
<link rel="alternate" type="application/json+oembed" href="/jsfinaday/wp-json/oembed/1.0/embed?url=http%3A%2F%2Fwww.turngeek.press%2Fjsfinaday%2Fchapter%2F7-additional-jsf-and-java-ee-technologies%2F" />
<link rel="alternate" type="text/xml+oembed" href="/jsfinaday/wp-json/oembed/1.0/embed?url=http%3A%2F%2Fwww.turngeek.press%2Fjsfinaday%2Fchapter%2F7-additional-jsf-and-java-ee-technologies%2F&#038;format=xml" />
<style type="text/css">
/* <![CDATA[ */
img.latex { vertical-align: middle; border: none; background: none; }
/* ]]> */
</style>

</head>
<body class="single single-chapter postid-30" id="7additionaljsfandjavaeetechnologies">
	<!-- Faccebook share js sdk -->
	<div id="fb-root"></div>
	<script>(function(d, s, id) {
	  var js, fjs = d.getElementsByTagName(s)[0];
	  if (d.getElementById(id)) return;
	  js = d.createElement(s); js.id = id;
	  js.src = "//connect.facebook.net/en_US/all.js#xfbml=1";
	  fjs.parentNode.insertBefore(js, fjs);
	}(document, "script", "facebook-jssdk"));</script>

<!-- a11y toolbar -->
<div class="a11y-toolbar">
	</div>
<!-- // a11y toolbar -->


	   	 
		<span itemscope itemtype="http://schema.org/WebPage" itemref="about copyrightHolder copyrightYear inLanguage publisher">		
		<div class="nav-container">
				<nav>
			
			 		<!-- Book Title -->
				    <h1 class="book-title"><a href="/jsfinaday/" title="Cloud Tutorial &#8211; JavaServer Faces in a Day" rel="home">Cloud Tutorial &#8211; JavaServer Faces in a Day</a></h1>
			    
			   
			    
					    <div class="sub-nav-left">
							<!-- Logo -->
							<h2 class="pressbooks-logo"><a href="/">TurnGeek Books</a></h2>
					    </div> <!-- end .sub-nav-left -->
			    
			    <div class="sub-nav-right">
			    
					    	
						
						<!-- --> 
				
				</div> <!-- end .sub-nav-right -->
			</nav>
			      
			  <div class="sub-nav">       
			     <!-- Author Name -->   
			    <div class="author-wrap"> 
			    									     	<h3>Marcus Schiesser and Martin Schmollinger</h3>
		     					     </div> <!-- end .author-name -->
		     
			  </div><!-- end sub-nav -->  
			    
				 
		</div> <!-- end .nav-container -->

	<div class="wrapper"><!-- for sitting footer at the bottom of the page -->	    
			<div id="wrap">	    
				<div id="content">

	 	
							<h2 class="entry-title">7 Additional JSF and Java EE Technologies</h2>
					<div class="nav">
  	<span class="previous"><a href="/jsfinaday/chapter/6-our-first-use-case-display-and-edit-campaign/">Previous</a></span>
  <!-- 	<h2 class="entry-title">7 Additional JSF and Java EE Technologies</h2> -->
  	<span class="next"><a href="/jsfinaday/chapter/8-implementation-of-the-remaining-use-cases/">Next</a></span>
    </div>				<div id="post-30" class="type-1 post-30 chapter type-chapter status-publish hentry">
					
					<div class="entry-content">
					  				    									
					<p>In the following section, we’ll look again at CDI bean technology and the JSF view declaration language, Facelets. In the first part, we’ll make use of the dependency injection mechanism (annotation <code>@Inject</code>) to establish references between the different controller beans of the application. Additional UI components are required for the implementation of our view. Also required is the ability to check inputs for validity (validators), to convert (converters) and to display error messages (FacesMessages). In addition to this, we’ll familiarize ourselves with the concept of view parameters, which can be used to pass, convert and validate parameters – as we did for the UI components &#8211; when a view is loaded using a HTTP GET request. Finally, we will explore how Ajax can be used to improve view dynamics.</p>
<h3>7.1 The @Inject Annotation</h3>
<p>It was all the way back in <a title="1 A Profiled Introduction" href="/javaee7inaweek/chapter/i-1-java-ee-7-the-standard-for-enterprise-java/" target="_blank">the theory about Java EE</a> that we first learned about the fundamental principle of dependency injection (DI). Now, we want to use it in our project. The basic idea is that we wish neither to explicitly create the beans ourselves nor to be responsible for their life cycle management in our application. Instead, these responsibilities should be undertaken by the application server (more accurately, the CDI container). Where we need a specific bean, we want simply to make a corresponding declaration and communicate to the application server &#8211; via an annotation &#8211; that it must provide the corresponding bean at precisely this point in runtime. The annotation used for this purpose is <code>@Inject</code> (package <code>javax.inject.Inject</code>). Let’s take the controller class <code>EditCampaignController</code> as an example. In it, we require a reference to an instance of the class <code>CampaignListProducer</code>, to enable us to include new campaigns in the campaign list.</p>
<pre class="lang:default decode:true">import javax.inject.Inject;
...
public class EditCampaignController implements Serializable {
...
   @Inject
   private CampaignListProducer campaignListProducer;
...
}</pre>
<p>We use the <code>campaignListProducer</code> variable within the <code>EditCampaignController</code> class without creating an object of the class with the <code>new</code> operator at all. In conventional Java programs, this would inevitably lead to the dreaded <code>NullPointerException</code> when executed. For Java EE applications, however, the application server makes sure a corresponding object is available at runtime. Classes that are to be injected in this way using a CDI container must possess a parameter-free constructor.</p>
<p>During this process, we must always pay attention the scope for which the the bean in question is declared. This will be determined for the bean in its class by an annotation (e.g. <code>@SessionScoped</code>) or inferred from the injection point. When using DI, the developer must be clear about whether, at a particular place, they wish to work with the same instance of a bean class or a new one. Failing to observe this point can have far-reaching impacts. We will discuss both the DI mechanism and the scope of CDI beans in our <a href="/cdiinaday" target="_blank">Cloud Tutorial CDI in a Day</a>.</p>
<h3>7.2  Text Input with Validation, Conversion and Error Messages</h3>
<p>As an example of JSF input components, let’s take a look at two components for text input. Text inputs are essential for many input screens. If we are dealing with texts short enough to be entered in one text line, a text field (<code>&lt;h:inputText&gt;</code>) is used. For text passages with multiple lines, a text area (<code>&lt;h:inputTextArea&gt;</code>) is used instead.</p>
<div class="textbox shaded">
<p><strong><code>&lt;h:inputText&gt;</code> in a nutshell</strong></p>
<p>Component for a one-line text input (text field)</p>
<p>Selected attributes:</p>
<p><code>id</code>: Unique identifier of the text field</p>
<p><code>value</code>: Content or value of the text field. Generally contains an EL expression that binds the text field to an attribute of a bean.</p>
</div>
<p>The binding of a bean property to an input component results in the current value of the property being shown when the component is displayed and reset when a new input is made. The binding is therefore relevant for both reading and writing the property. The following example could be used to input an international bank account number:</p>
<p>&nbsp;</p>
<pre class="lang:default decode:true">&lt;h:inputText id="iban"value="#{donateMoneyController.donation.account.iban}"&gt;

&lt;/h:inputText&gt;</pre>
<p>JSF renders the <code>&lt;h:inputText&gt;</code> tag on the server’s side to an HTML <code>&lt;input&gt;</code> tag with the value text for the attribute <code>type</code> (<code>&lt;input … type="text" …  /&gt;</code>). The attribute <code>id</code> enables us to assign a unique identifier for the UI component within the Facelet. Different UI components can then use the <code>id</code> to refer to one another. An example of this can be found a little later on in the chapter, under the heading <em>Error Messages</em>.</p>
<div class="textbox shaded">
<p>&lt;h:inputTextArea&gt; in a nutshell</p>
<p>Components for multi-line text inputs</p>
<p>Selected attributes:</p>
<p>id: Unique identifier of the component</p>
<p>value: Content or value of the text component. Generally contains an EL expression that binds the text area   to an attribute of a bean.</p>
<p>rows: Number of text rows</p>
<p>cols: Number of text columns</p>
<p>readonly: Restrict to read-only access</p>
</div>
<p>The <code>&lt;h:inputTextArea&gt;</code> tag is converted into a correspondingly configured <code>&lt;textarea&gt;</code> HTML tag. The component can be configured via a range of attributes. In the following example, we use a text area to display the URL of a donation form:</p>
<pre class="nums-toggle:false wrap:true wrap-toggle:false plain-toggle:false expand-toggle:false lang:default decode:true">&lt;h:inputTextarea 
	id="url" 
	rows="6" 
	cols="30" 
	readonly="true" 
	value="#{editDonationFormController.url}" 
/&gt;</pre>
<p><strong>Validation</strong></p>
<p>Checking the validity of data entered is a central element of any web application, since a failure to check can lead to undesirable side effects. For example, invalid inputs can cause runtime errors that lead to unhandled errors on the server. JSF therefore provides a number of small-scale standard validation options. These make it possible to check the length of a text input or the number area of a numeric input, or to clarify whether an input has actually occurred. Since these options are generally unable to handle the complexity of real applications, the developer is usually also required to program their own validators. However, we will stick to standard validators for the purposes of this application.</p>
<p>We intend only to carry out a rough validation in the first iteration of our implementation. Accordingly, the check we’ll be using most frequently is the one to determine whether an input has actually occurred. This can be requested using the <code>&lt;f:validateRequired&gt;</code> tag. It will then be applied to all input components into which this tag was embedded as a child.</p>
<div class="textbox shaded">
<p><strong><code>&lt;f:validateRequired&gt;</code> in a nutshell</strong></p>
<p>This validator checks the existence of a value in an input component.</p>
<p>Selected attributes:</p>
<p><code>for</code>: Contains the ID of the input component to be validated</p>
</div>
<p>The reference to the validator can take place via the attribute <code>for</code> or through the embedding of the validator tag in the tag of the input component. The following example uses the latter approach. The validator relates to the input field with the ID <code>iban</code>:</p>
<pre class="nums-toggle:false wrap:true wrap-toggle:false plain-toggle:false expand-toggle:false lang:default decode:true">&lt;h:inputText id="iban"
		value="#{donateMoneyController.donation.account.iban}"&gt;
	&lt;f:validateRequired/&gt;
&lt;/h:inputText&gt;</pre>
<p>Another option for validating inputs within our view is to check the data against a regular expression. The <code>&lt;f:validateRegEx&gt;</code> tag can be used to do this.</p>
<div class="textbox shaded">
<p><strong><code>&lt;f:validateRegex&gt;</code> in a nutshell</strong></p>
<p>This valdator uses a regular expression to check the value of an input component.</p>
<p>Selected attributes:</p>
<p><code>for</code>: Contains the ID of the input component to be validated</p>
<p><code>pattern</code>: Regular expression</p>
</div>
<p>The following example tag applies to an input component with the ID <code>bg_color</code> and is used to check two things: one, that the value consists of an arbitrarily defined combination of upper case letters from A to F, lower case letters from a to f or numbers from 0 to 9; and two, that an overall minimum length of 6 characters is reached:</p>
<pre class="lang:default decode:true">&lt;f:validateRegex for="bg_color" pattern="[A-Fa-f0-9]{6}" /&gt;</pre>
<p>We can also use validators to check number areas. Let’s say, for example, that we have a double value and want to make sure that it’s always in a certain range. We can use the <code>&lt;f:validateDoubleRange&gt;</code> tag to do so.</p>
<div class="textbox shaded">
<p><strong><code>&lt;f:validateDoubleRange&gt;</code> in a nutshell</strong></p>
<p>This validator checks whether the value of an input component lies within a specified range.</p>
<p>Selected attributes:</p>
<p><code>for</code>: Contains the ID of the input component to be validated</p>
<p><code>minimum</code>: Minimum input value</p>
<p><code>maximum</code>: Maximum input value</p>
</div>
<p>The following example checks whether the value entered is at least 10.0.</p>
<pre class="nums-toggle:false wrap:true wrap-toggle:false plain-toggle:false expand-toggle:false lang:default decode:true">&lt;h:inputTextid="a_targetAmount"
		value="#{campaignProducer.selectedCampaign.targetAmount}"&gt;
	&lt;f:validateRequired/&gt;
	&lt;f:validateDoubleRange minimum="10.0"/&gt;
&lt;/h:inputText&gt;</pre>
<p>If the input consists of text, we can check its length using the length validator (<code>&lt;f:validateLength&gt;</code>).</p>
<div class="textbox shaded">
<p><strong><code>&lt;f:validateLength&gt;</code> in a nutshell</strong></p>
<p>This validator checks whether the value of an input component falls in a particular length interval (length = number of characters)</p>
<p>Selected attributes:</p>
<p><code>for</code>: Contains the ID of the input component to be validated</p>
<p><code>minimum</code>: Minimum length</p>
<p><code>maximum</code>: Maximum length</p>
</div>
<p>The following example checks that the length of the input is a minimum of 4 and a maximum of 30 characters.</p>
<pre class="nums-toggle:false wrap:true wrap-toggle:false plain-toggle:false expand-toggle:false lang:default decode:true">&lt;h:inputText id="a_name" value="#{campaignProducer.selectedCampaign.name}"&gt;
	&lt;f:validateRequired/&gt;
	&lt;f:validateLength minimum="4" maximum="30"/&gt;
&lt;/h:inputText&gt;</pre>
<p><strong>Converters</strong></p>
<p>In many cases, a conversion must take place before any validation can be carried out. HTTP communication is based on strings, while beans and validators generally use other types of data. In the example above, a conversion is not necessary only because the <code>name </code>property of the <code>Campaign</code> class is of the type <code>String</code>. The <code>converter</code> attribute of input and output components can be used to register converters for components. For this to occur, the <code>converter</code> attribute must contain the ID of the converter as a value. Alternatively, the tag <code>&lt;f:converter&gt;</code> can be used as a child element, whereby its <code>id</code> attribute activates a particular converter for the enclosing components.</p>
<p>JSF offers converters for standard data types. These converters are located in the package <code>javax.faces.convert</code>. ‎Tab. 4-2 lists the non-configurable converters with data type and converter ID.</p>
<table>
<tbody>
<tr>
<td><strong>Converter</strong></td>
<td><strong>Java Type</strong></td>
<td><strong>ID</strong></td>
</tr>
<tr>
<td>BigDecimalConverter</td>
<td>BigDecimal</td>
<td>javax.faces.BigDecimal</td>
</tr>
<tr>
<td>BigIntegerConverter</td>
<td>BigInteger</td>
<td>javax.faces.BigInteger</td>
</tr>
<tr>
<td>CharacterConverter</td>
<td>Character</td>
<td>javax.faces.Character</td>
</tr>
<tr>
<td>BooleanConverter</td>
<td>Boolean</td>
<td>javax.faces.Boolean</td>
</tr>
<tr>
<td>ByteConverter</td>
<td>Byte</td>
<td>javax.faces.Byte</td>
</tr>
<tr>
<td>ShortConverter</td>
<td>Short</td>
<td>javax.faces.Short</td>
</tr>
<tr>
<td>IntegerConverter</td>
<td>Integer</td>
<td>javax.faces.Integer</td>
</tr>
<tr>
<td>LongConverter</td>
<td>Long</td>
<td>javax.faces.Long</td>
</tr>
<tr>
<td>FloatConverter</td>
<td>Float</td>
<td>javax.faces.Float</td>
</tr>
<tr>
<td>DoubleConverter</td>
<td>Double</td>
<td>javax.faces.Double</td>
</tr>
</tbody>
</table>
<p><strong>Tab. 4-2</strong>     Non-configurable JSF standard converters</p>
<p>The standard converters are applied automatically when an input component is bound to a bean property of another type.</p>
<p>There are two other converter classes for the conversion of dates and numbers. The behaviour of these converters can be configured. The <code>DateTimeConverter</code> enables the conversion of a <code>java.util.Date</code> object into a range of date formats as strings (and vice versa). The converter can be embedded in the Facelet using the tag <code>&lt;f:convertDateTime&gt;</code>. Configuration takes place via attributes of the tag. Since we do not wish to use this converter, we’ll refrain from going into any more detail about it here.</p>
<p>The converter class <code>NumberConverter</code>, meanwhile, enables the same powerful formatting of numbers. This converter can be integrated in a Facelet using the tag <code>&lt;f:convertNumber&gt;</code>. We have already seen an example of how numbers can be interpreted as currency amounts, since this occurred in the first use case.</p>
<p>The following example shows another conversion of numbers. Before being validated, the input here is converted into a number with exactly two places after the comma:</p>
<pre class="nums-toggle:false wrap:true wrap-toggle:false plain-toggle:false expand-toggle:false lang:default mark:3 decode:true">&lt;h:inputText id="a_targetAmount" 
		value="#{campaignProducer.selectedCampaign.targetAmount}"&gt;
	&lt;&lt;f:convertNumber maxFractionDigits="2" minFractionDigits="2"/&gt;
	&lt;f:validateRequired/&gt;
	&lt;f:validateDoubleRange minimum="10.0"/&gt;
&lt;/h:inputText&gt;
</pre>
<p>As we did with the validators, we can also program our own converters to meet specific requirements.</p>
<p>We have now covered how validators and converters can be added to Facelet UI components. However, we have not explained how the user receives the information that their input has violated a validation rule or that a conversion has failed. This will be discussed in the next section.</p>
<p><strong>Error Messages</strong></p>
<p>Validations and conversions can both cause errors. These errors must be displayed to the user to allow them to correct their input accordingly. JSF defines a multi-lingual set of error messages for some typical problems that can occur with the different input components. Here, JSF differentiates between messages generated specifically for a single component and messages generated for the entire view. In addition, some error messages have both a short and a long form. Through the components, it is possible to overwrite standard error messages with your own. In the following example, an error message is set using the <code>validatorMessage</code> attribute of the text input.</p>
<pre class="lang:default decode:true">&lt;h:inputText id="a_name" value="#{campaignProducer.selectedCampaign.name}"
	validatorMessage="The name must be at least 4 and max. 30 characters long."&gt;
	&lt;f:validateRequired /&gt;
	&lt;f:validateLength minimum="4" maximum="30" /&gt;
&lt;/h:inputText&gt;
</pre>
<p>Of course, it’s also possible to store your own error messages again in properties files for the supported languages.</p>
<p>Error messages can be displayed on the page using special tags. The <code>&lt;h:message&gt;</code> tag is provided for displaying the error message of a particular component.</p>
<div class="textbox shaded">
<p><strong><code>&lt;h:message&gt;</code> in a nutshell</strong></p>
<p>Displaying a message/error message for an individual component</p>
<p>Selected attributes:</p>
<p><code>for</code>: References the component whose messages should be displayed</p>
<p><code>style</code>: CSS style of the displayed message</p>
</div>
<p>The error message can be individually configured using other attributes. In the following example, we use the attribute <code>style</code> to present the error message in the color red. Special attributes of the tag can also be used to determine the formatting of the error output according to its degree of severity. The error message appears at the location you positioned the tag. In the following example, that location is directly below the input field.</p>
<pre class="nums-toggle:false wrap:true wrap-toggle:false plain-toggle:false expand-toggle:false lang:default mark:5 decode:true">&lt;h:inputText id="name"
		value="#{donateMoneyController.donation.donorName}"&gt;
	&lt;f:validateRequired /&gt;
&lt;/h:inputText&gt;
&lt;h:message for="name" style="color: red;" /&gt;
</pre>
<p>The <code>&lt;h:messages&gt;</code> tag can be used to display all of a page’s errors in a particular place. When requesting for the errors to be displayed, you can choose whether only global (that is, component-independent) errors are shown, or whether errors assigned to specific components should be displayed as well.</p>
<div class="textbox shaded">
<p><strong><code>&lt;h:messages&gt;</code> in a nutshell</strong></p>
<p>Display all messages/error messages of a view</p>
<p>Selected attributes:</p>
<p><code>globalOnly</code>: Display only the component-independent messages of the page (Default false).</p>
<p><code>showDetail</code>: Display the detailed form of the message (Default false)</p>
<p><code>showSummary</code>: Display the short form of the messages (Default true)</p>
<p><code>style</code>: CSS style for the display</p>
</div>
<p>The selection of errors displayed can be controlled by the attribute <code>globalOnly</code>. While the <code></code> tag always displays the long form of the message, you can use the <code>showDetail</code> and <code>showSummary</code> attributes of <code></code> to switch between the long and short forms of the message. The following tag would represent the short forms of all the error messages associated with a particular view.</p>
<p>Behind the scenes, error messages are represented by the class <code>FacesMessage</code> in the package <code>javax.faces.application</code>. Thus, error messages can also be created directly in the program code of the backing beans. It is possible for us to create error messages with varying grades of severity. The constants for this grading are also defined in the class <code>FacesMessages</code>: <code>SEVERITY_ERROR</code>, <code>SEVERITY_FATAL</code>, <code>SEVERITY_INFO</code>, <code>SEVERITY_WARN</code>. The above standard validators create errors of the severity grade <code>SEVERITY_ERROR</code>. Error messages created in the Java code are also displayed by the above-mentioned <code>&lt;h:message&gt;</code> and <code>&lt;h:messages&gt;</code> tags. As we have already mentioned, special attributes of the tags can be used to format the error outputs differently according to their degree of severity.</p>
<p>Each error message relates to a specific request of a JSF page. In JSF, the status of a request &#8211; including all information for the generation of the response – is managed in an object of the class <code>FacesContext</code> from the package <code>javax.faces.context</code>. This object also contains the error messages. Error messages created in the Java code of the backing beans must therefore be added to the current instance of <code>FacesContext</code>. What follows is an example of how we can get access to the current instance of <code>FacesContext</code> in a backing bean and how an error message can be added.</p>
<pre class="nums-toggle:false wrap:true wrap-toggle:false plain-toggle:false expand-toggle:false lang:default decode:true">FacesContext.getCurrentInstance().addMessage(null, 
		new FacesMessage(FacesMessage.SEVERITY_INFO, "Thank you for your donation!", null));
</pre>
<p>The tag <code>&lt;h:message&gt;</code> or <code>&lt;h:messages&gt;</code> will include this message when the response page is generated.</p>
<h3>7.3 The Grid Layout of UI Components</h3>
<p>A frequently used technique in views is the alignment of UI components to a grid. The <code>&lt;h:panelGrid&gt;</code> tag maps the UI components to a grid and is rendered as a table in HTML.</p>
<div class="textbox shaded">
<p><strong><code>&lt;h:panelGrid&gt;</code> in a nutshell</strong></p>
<p>This tag enables the alignment of components to a grid structure and creates an HTML table.</p>
<p>Selected attributes:</p>
<p><code>columns</code>: Number of columns per row</p>
</div>
<p>The components within the <code>&lt;h:panelGrid&gt;</code> tag are allocated to the grid row-by-row from left to right. If there are multiple components to be displayed within a grid element, they can be grouped using the <code>h:panelGroup</code> tag and the whole group allocated to that element. The following example shows the creation of an HTML table with two rows and two columns. The values of the <code>value</code> attribute are assigned to the four cells of the table from left to right and from top to bottom.</p>
<pre class="nums-toggle:false wrap:true wrap-toggle:false plain-toggle:false expand-toggle:false lang:default decode:true">...
&lt;h:panelGrid columns="2"&gt;
	&lt;h:outputLabel value="topleft"&gt;&lt;/h:outputLabel&gt;
	&lt;h:outputLabel value="topright"&gt;&lt;/h:outputLabel&gt;
	&lt;h:outputLabel value="bottomleft"&gt;&lt;/h:outputLabel&gt;			
	&lt;h:panelGroup&gt;
		&lt;h:outputLabel value="bottom"&gt;&lt;/h:outputLabel&gt;
		&lt;h:outputLabel value="right"&gt;&lt;/h:outputLabel&gt;
	&lt;/h:panelGroup&gt;
&lt;/h:panelGrid&gt;
...
</pre>
<h3>7.4 Choice Components</h3>
<p>Forms are required not only to provide the option for entering free text, but also to offer a choice between one or more predefined values or to enable certain options. JSF provides a variety of components to help us implement this. In the following section, we’ll take a closer look at two of these components, both of which are required for our implementation.</p>
<p><strong>The Combo-Box (h:selectOneMenu)</strong></p>
<p>Our first component enables the user to select one option from a list of predefined values.</p>
<div class="textbox shaded">
<p><strong><code>&lt;h:selectOneMenu&gt;</code> in a nutshell</strong></p>
<p>Component for selecting a value from a list</p>
<p>Selected attributes:</p>
<p><code>id</code>: Unique identifier of the component</p>
<p><code>value</code>: Content or value of the combo box. Generally contains an EL expression that binds the combo box to an attribute of a bean. The current value of the bean attribute is displayed to the user.</p>
</div>
<p>The combo box is displayed in such a way that the currently selected value is the only one visible to the user. As soon as the user clicks on the selection bar, all of the possible choices appear. Java refers to this as a <em>combo</em> box, as do other GUI frameworks. The <code>&lt;h:selectOneMenu&gt;</code> tag is rendered to HTML as a <code>&lt;select&gt;</code> tag with the attribute <code>size</code> that has the value 1. The <code>&lt;f:selectItem&gt;</code> tag can be used within the <code>&lt;h:selectOneMenu&gt;</code> tag to specify the possible values.</p>
<div class="textbox shaded">
<p><strong><code>&lt;f:selectItem&gt;</code> in a nutshell</strong></p>
<p>Component for representing a value from a list of choices/drop-down list</p>
<p>Selected attributes:</p>
<p><code>itemLabel</code>: a visible representation of the value for the user</p>
<p><code>itemValue</code>: The actual value of the choice, which is also used as a result for the bound bean attribute</p>
</div>
<p>The <code>&lt;f:selectItem&gt;</code> tags are rendered to HTML as <code>&lt;option&gt;</code> elements. The following example shows a choice of three elements:</p>
<pre class="nums-toggle:false wrap:true wrap-toggle:false plain-toggle:false expand-toggle:false lang:default decode:true">&lt;h:selectOneMenu id="bgColor"
		value="#{editDonationFormController.bgColor}"&gt;
	&lt;f:selectItem itemLabel="#FFFFFF" itemValue="FFFFFF" /&gt;
	&lt;f:selectItem itemLabel="#000000" itemValue="000000" /&gt;
	&lt;f:selectItem itemLabel="#FF0000" itemValue="FF0000" /&gt;
&lt;/h:selectOneMenu&gt;
</pre>
<p><strong>The Checkbox &lt;h:selectBooleanCheckbox&gt;</strong></p>
<p>Our second component enables the checking or unchecking of an option. This graphic component is also known as a <em>checkbox</em>. It is embedded in the view using the <code>&lt;h:selectBooleanCheckbox&gt;</code> tag.</p>
<div class="textbox shaded">
<p><strong><code>&lt;h:selectBooleanCheckbox&gt;</code> in a nutshell</strong></p>
<p>Component for checking or unchecking a non-compulsory option</p>
<p>Selected attributes:</p>
<p><code>value</code>: Content or value of the checkbox. Generally contains an EL expression that binds the checkbox to a boolean attribute of a bean.</p>
</div>
<p>If the graphical box is activated by the user, the value is set to <code>true</code>. If not, it is set to <code>false</code>. In the example below, the tag is followed by a text that explains to the user the consequence of checking a particular box within the application.</p>
<pre class="nums-toggle:false wrap:true wrap-toggle:false plain-toggle:false expand-toggle:false lang:default decode:true">&lt;h:selectBooleanCheckbox 
		value="#{donateMoneyController.donation.receiptRequested}"/&gt; Yes, I would like a donation receipt.</pre>
<h3> 7.5 GET Parameter Processing in a View</h3>
<p>JSF offers a mechanism by which the parameters of an HTTP GET request in a view can be directly bound to the properties of a bean. In principle, therefore, the setting of parameters works in exactly the same way as the setting of values from other input components. The values can be converted and validated using the same methods. The parameters are declared in the metadata of the Facelet within the <code>&lt;f:metadata&gt;</code> tag, which is located in the page’s <code>&lt;h:head&gt;</code> tag. The <code>&lt;f:viewParam&gt;</code> tag can be used to request a view parameter.</p>
<div class="textbox shaded">
<p><strong><code>&lt;f:viewParam&gt;</code> in a nutshell</strong></p>
<p>Component that represents a parameter of an HTTP GET request</p>
<p>Selected attributes:</p>
<p><code>id</code>: Unique identifier of the component</p>
<p><code>name</code>: Name of the GET parameter of the request</p>
<p><code>value</code>: Generally contains an EL expression that binds the parameter to an attribute of a bean</p>
</div>
<p>Converters and validators can be bound to the properties of backing beans in the same way as the text inputs and displays we looked at earlier. The following code snippet shows the declaration of a parameter with the name <code>bgColor</code>, which is adopted as the value of a backing bean property directly following successful validation. Its value is also validated by a regular expression.</p>
<pre class="nums-toggle:false wrap:true wrap-toggle:false plain-toggle:false expand-toggle:false lang:default decode:true">...
&lt;h:head&gt;
	&lt;title&gt;Geld Spenden&lt;/title&gt;
	&lt;meta charset="utf-8"/&gt;
	&lt;f:metadata&gt;
		&lt;f:viewParam id="bgColor" name="bgColor"
				value="#{donateMoneyController.bgColor}"&gt;
			&lt;f:validateRegex pattern="[A-Fa-f0-9]{6}"/&gt;
		&lt;/f:viewParam&gt;
	...
	&lt;/f:metadata&gt;
&lt;/h:head&gt;
...
</pre>
<h3>7.6  Ajax – In Need of a Little More Dynamic?</h3>
<p>We have so far experienced JSF in a very static way. The JSF tags are converted into HTML and the applications work strictly according to the page-oriented request-response principle: an HTTP request returns an HTML page. New requests are sent to the server using the page’s links and buttons and new complete HTML pages are returned. This method of processing has the result that the application is sometimes a little cumbersome for the user to operate. With each click, the page is requested, sent and displayed &#8211; despite the fact that the section of the page to be updated is sometimes only small. A few years ago, the development of Ajax (Asynchronous JavaScript and XML) brought us a general concept for increasing the interactivity of web applications. It works by ensuring that user actions result only in changes to the relevant parts of a page that is already displayed. Through partial requests, a section of the page is furnished with new data and its appearance updated accordingly instead of a completely new page being requested. The experience of the user is significantly enhanced as a result of the shorter response times. The technology enables web applications to be designed in the style of desktop applications and not merely as a series of linked web pages.</p>
<p>Ajax itself is based on a wide range of technlogies. The most important aspect, however, is that JavaScript is used alongside HTML in the browser. The JavaScript code communicates with the server via standardized interfaces, with the communications taking place parallel to the conventional HTTP request-response protocol. On the client side, JavaScript carries out the rendering of the page section to be updated.</p>
<p>The JavaScript API provided by JSF forms the basis for the integration of Ajax in Java EE applications. Developers can use this API directly or opt for the declarative variant through the tag <code>&lt;f:ajax&gt;</code>. We can equip a UI component with Ajax functionality by including the <code>&lt;f:ajax&gt;</code> tag as a child element in the declaration of the component. The exact actions of the <code>&lt;f:ajax&gt;</code> tag can be determined using its attributes.</p>
<div class="textbox shaded">
<p><strong><code>&lt;f:ajax&gt;</code> in a nutshell</strong></p>
<p>This tag is used to determine the “Ajax behavior” of other components. Ajax behaviour is activated in a component by embedding this tag. For multiple components, the &lt;f:ajax&gt; tag can be used to enclose the components.</p>
<p>Selected attributes:</p>
<p><code>execute</code>: List of components of the view that should run through all processing stages of the Faces request up to rendering within an Ajax request</p>
<p><code>render</code>: List of components of the view that should only be executed for the rendering at the end of an Ajax request</p>
</div>
<p>The following code snippet shows the use of the &lt;f:ajax&gt; tag within a URL display that is dependent on a choice in a <em>combo box</em>. The tag is used to update the page without having to completely reload it.</p>
<pre class="nums-toggle:false wrap:true wrap-toggle:false plain-toggle:false expand-toggle:false lang:default mark:8 decode:true">...
&lt;h:outputLabel value="Textfarbe:"&gt;&lt;/h:outputLabel&gt;
&lt;h:selectOneMenu id="textColor"
		value="#{editDonationFormController.textColor}"&gt;
	&lt;f:selectItem itemLabel="#FFFFFF" itemValue="FFFFFF" /&gt;
	&lt;f:selectItem itemLabel="#000000" itemValue="000000" /&gt;
	&lt;f:selectItem itemLabel="#FF0000" itemValue="FF0000" /&gt;
	&lt;f:ajax render="url" /&gt;
&lt;/h:selectOneMenu&gt;
...
&lt;h:inputTextarea &lt;strong&gt;id="url"&lt;/strong&gt; rows="6" cols="30" readonly="true"
		value="#{editDonationFormController.url}" /&gt;
...
</pre>
<p>To understand this snippet, we must keep in mind that a dependency exists between the values of properties <code>textColor</code> and <code>url</code> of the bean <code>EditDonationFormController</code>. If we change the value of textColor, the value of url also changes. Following a change in the <em>combo box</em> value with the ID  <code>textColor</code>, the <code>&lt;f:ajax&gt;</code> tag ensures that only the JSF component with the ID <code>url</code> (that is, the text area component) is updated.</p>
<p>In order to completely understand the processing of Ajax requests in the context of JSF, we must be familiar with the processing model of a <em>Faces request</em> and how it is modified with respect to an Ajax request. This model is very complex, and a proper explanation would go beyond the scope of this chapter. For this reason, we recommend you to take a look at JSF specialist literature like <a title="Bibliography" href="/javaee7/back-matter/bibliography/">Leonard, 2014</a>.</p>
<h3> 7.7 HTML5-Friendly Markup</h3>
<p>JSF 2.2 uses HTML5 to provide an improvement in page rendering. This means that by default, a Faces request is answered by an HTML5 page, which an experienced web developer will be able to recognize easily from the first line (<code>&lt;! DOCTYPE html &gt;</code>).</p>
<p>HTML5 adds new attributes to a number of existing HTML tags. These attributes include the <code>type</code> attribute of <code>input</code> elements, which can be used to store semantic information about the type of input. Supported values here include <code>text</code>, <code>search</code>, <code>email</code>, <code>url</code> or <code>tel</code>.</p>
<p>Additionally, it is also possible to attach metadata to HTML elements that are not represented in the browser but can be requested with JavaScript. In the HTML specification, this mechanism is referenced with the designation <em>custom-data-attribute</em>. This attribute does not have a fixed name, but always begins with the prefix <code>data-</code>. Both of these HTML5 improvements enable web clients to interpret data semantically.</p>
<p>JSF UI components do not support these new attributes automatically. Upon first noticing this, we might think of it as something that should be corrected within a new version. On closer inspection, however, we see that this is completely unnecessary, since JSF either does not interpret these attributes during rendering or must convert them into HTML.</p>
<p>Rather, it would be useful to provide a general mechanism with which any pair of attribute names and values can be specified, but then passed along to the components responsible for rendering. Since we are dealing with metadata that is interpreted by the web client and not on the server side, this option is a viable one. Thus, JSF simply passes the attributes (with their values) to the HTML5 client, giving the mechanism its name: <em>pass-through attributes</em>. This enables JSF to use HTML5 extensions without having to re-implement its own components.</p>
<p>Let’s look at the following example. In HTML5, INPUT elements have a new attribute, <code>placeholder</code>. This attribute can be used to place text in the input field in gray until the field receives focus. This enables the implementation of very simple <em>inline labels</em>: labels of input fields that are not located over or before the respective field but are contained within the field itself. This is useful in that it allows us to provide informational texts for filling out an input field.</p>
<p>The attribute <code>placeholder</code> does not exist for JSF components like <code>&lt;h:inputText&gt;</code>. With the help of the <em>pass-through mechanism</em>, however, the new functionality can still be used in the client. In <a title="4.7 Implementation of the Remaining Use Cases" href="/jsfinaday/chapter/8-implementation-of-the-remaining-use-cases/" target="_blank">chapter 8</a>, we will introduce a Facelet for editing and creating campaigns (<code>editCampaign.xhtml</code>). This contains a number of text fields, including one for entering the name of a campaign. We can determine an inline label for this field as follows:</p>
<pre class="nums-toggle:false wrap:true wrap-toggle:false plain-toggle:false expand-toggle:false lang:default mark:5,6 decode:true">...
&lt;h:inputText id="a_name"
		value="#{campaignProducer.selectedCampaign.name}"
		validatorMessage="The name must be at least 4 and max. 30 characters long."&gt;
	&lt;f:passThroughAttribute name="placeholder"
			value="Name of the campaign" /&gt;
	&lt;f:validateRequired /&gt;
	&lt;f:validateLength minimum="4" maximum="30" /&gt;
&lt;/h:inputText&gt;
...
</pre>
<p>After rendering, the resulting HTML5 page features an input field containing the attribute <code>placeholder</code> with the specified value:</p>
<pre class="nums-toggle:false wrap:true wrap-toggle:false plain-toggle:false expand-toggle:false lang:default mark:2 decode:true">&lt;input id="j_idt8:a_name" type="text" name="j_idt8:a_name" 
	placeholder="Name der Spendenaktion" /&gt;
</pre>
<p>In this way, new HTML5 capabilities can be integrated in the result of the rendering. The HTML5-capable browser then takes care of the corresponding interpretation of the attributes.</p>
<h3>Discussion</h3>
<p>Use the message board below to give the authors your feedback or to discuss this page&#8217;s topic with other readers (in English please!). Please don&#8217;t expect the authors to answer directly, but they might update the content of this site according to your feedback.<br />
<script src="/js/disqus.js" type="text/javascript"></script></p>

					</div><!-- .entry-content -->
				</div><!-- #post-## -->

			
				</div><!-- #content -->
			
				<!-- Share buttons -->
	<div class="share-wrap-single">
		<ul class="share share-single">
						<li class="email"><a href="mailto:?subject=I%20wanted%20to%20share%20this%20post%20with%20you%20from%20Cloud%20Tutorial%20-%20JavaServer%20Faces%20in%20a%20Day&amp;body=7%20Additional%20JSF%20and%20Java%20EE%20Technologies%20-%20http%3A%2F%2Fwww.turngeek.press%2Fjsfinaday%2Fchapter%2F7-additional-jsf-and-java-ee-technologies%2F" title="Email to a friend" target="_blank">Share via Email</a>
			</li>
			<li class="twitter"><a href="https://twitter.com/share" class="twitter-share-button" data-count="horizontal" data-width="97px">Tweet</a>
<script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0];if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src="//platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script></li>
			<li class="facebook"><div class="fb-like" data-send="false" data-layout="button_count" data-width="60" data-show-faces="false"></div></li>
									
		</ul>
	</div><!-- end .share-wrap-single --> 
			
				
		
	<div id="sidebar">

		<ul id="booknav">
		<!-- If Logged in show ADMIN -->
								
				<li class="home-btn"><a href="/jsfinaday">Home</a></li>

		<!-- TOC button always there -->
				<li class="toc-btn"><a href="/jsfinaday/table-of-contents">Table of Contents</a></li>
			</ul>

		<!-- Pop out TOC only on READ pages -->
						<div id="toc">
			<a href="#" class="close">Close</a>
			<ul>
				<li><h4><!-- Front-matter --></h4></li>
				<li>
					<ul>
																		<li class="front-matter introduction"><a href="/jsfinaday/front-matter/introduction-2/">Introduction</a>
              						</li>
											</ul>
				</li>
								<li><h4>								Chapters								</h4></li>
				<li>
					<ul>
																				<li class="chapter type-1"><a href="/jsfinaday/chapter/1-outlook/">1 Outlook</a>
                							</li>
																				<li class="chapter type-1"><a href="/jsfinaday/chapter/2-project-setup/">2 Project Setup</a>
                							</li>
																				<li class="chapter type-1"><a href="/jsfinaday/chapter/3-domain-classes-as-javabeans/">3 Domain Classes as JavaBeans</a>
                							</li>
																				<li class="chapter type-1"><a href="/jsfinaday/chapter/4-internationalization/">4 Internationalization</a>
                							</li>
																				<li class="chapter type-1"><a href="/jsfinaday/chapter/5-the-templating-system/">5 The Templating System</a>
                							</li>
																				<li class="chapter type-1"><a href="/jsfinaday/chapter/6-our-first-use-case-display-and-edit-campaign/">6 Our First Use Case: "Display and Edit Campaign"</a>
                							</li>
																				<li class="chapter type-1"><a href="/jsfinaday/chapter/7-additional-jsf-and-java-ee-technologies/">7 Additional JSF and Java EE Technologies</a>
                							</li>
																				<li class="chapter type-1"><a href="/jsfinaday/chapter/8-implementation-of-the-remaining-use-cases/">8 Implementation of the Remaining Use Cases</a>
                							</li>
																				<li class="chapter type-1"><a href="/jsfinaday/chapter/9-new-functionalities-in-java-ee-7/">9 New Functionalities in JSF 2.2</a>
                							</li>
																				<li class="chapter type-1"><a href="/jsfinaday/chapter/10-a-brief-venture-into-primefaces/">10 A Brief Venture into PrimeFaces</a>
                							</li>
																				<li class="chapter type-1"><a href="/jsfinaday/chapter/11-exercises/">11 Exercises</a>
                							</li>
											</ul>
				</li>
								<li><h4><!-- Back-matter --></h4></li>
				<li>
					<ul>
																		<li class="back-matter conclusion"><a href="/jsfinaday/back-matter/what-next/">What Next?</a>
              						</li>
											</ul>
				</li>
			</ul>
		</div><!-- end #toc -->
		

	</div><!-- end #sidebar -->
	
	</div><!-- #wrap -->
	<div class="push"></div>
	
	</div><!-- .wrapper for sitting footer at the bottom of the page -->


<div class="footer">
	<div class="inner">
								
			
						<p class="cie-name"><a href="http://pressbooks.com">Pressbooks.com: Simple Book Production</a></p>
	</div><!-- #inner -->
</div><!-- #footer -->
</span><!-- schema.org -->
<script type='text/javascript' src='/jsfinaday/wp-content/plugins/pressbooks/themes-book/pressbooks-book/js/keyboard-nav.js?ver=20130306'></script>
<script type='text/javascript' src='/jsfinaday/wp-includes/js/wp-embed.min.js?ver=4.4'></script>
</body>
</html>
